<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Raiku Love Collector</title>
    <style>
        * {
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #000204 0%, #0a0f0a 50%, #000204 100%);
            font-family: 'Arial Black', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            color: #FDFDFF;
            position: relative;
        }
        canvas {
            border: 4px solid #C0FF38;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(192,255,56,0.35);
            background: radial-gradient(circle at center, #0f150a, #000204);
            max-width: 95vw;
            max-height: 82vh;           /* slightly more vertical space on mobile */
            touch-action: none;
        }
      
        #logo {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            width: 200px;
            height: auto;
            filter: drop-shadow(0 0 12px rgba(192,255,56,0.7));
            animation: neonPulse 2s ease-in-out infinite alternate;
        }
        @keyframes neonPulse {
            from { filter: drop-shadow(0 0 8px rgba(192,255,56,0.5)); }
            to   { filter: drop-shadow(0 0 20px rgba(192,255,56,0.9)); }
        }
        #ui {
            position: absolute;
            top: 120px;                 /* pushed down more from logo */
            left: 15px;
            font-size: 22px;
            font-weight: bold;
            color: #C0FF38;
            text-shadow: 0 0 10px rgba(192,255,56,0.6);
            z-index: 50;
            background: rgba(0,2,4,0.65);
            padding: 12px 16px;
            border-radius: 15px;
            border: 1px solid #C0FF38;
            backdrop-filter: blur(8px);
        }
        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(28px, 6vw, 42px);
            text-align: center;
            text-shadow: 0 0 15px rgba(192,255,56,0.8);
            display: none;
            z-index: 200;
            background: rgba(0,2,4,0.92);
            padding: 40px 60px;
            border-radius: 25px;
            max-width: 90vw;
            box-shadow: 0 20px 60px rgba(192,255,56,0.3);
            border: 4px solid #C0FF38;
            color: #C0FF38;
        }
        button {
            background: linear-gradient(45deg, #C0FF38, #a8e02c);
            color: #000204;
            border: none;
            padding: 15px 35px;
            font-size: 22px;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(192,255,56,0.5);
            transition: all 0.3s ease;
        }
        button:hover {
            transform: scale(1.08);
            box-shadow: 0 15px 45px rgba(192,255,56,0.8);
        }
        @media (max-width: 768px) {
            #logo {
                width: 160px;
                top: 12px;
                left: 12px;
            }
            #ui {
                top: 110px;             /* even more space on mobile */
                left: 10px;
                font-size: 18px;
                padding: 10px 14px;
            }
            canvas {
                max-height: 78vh;       /* give dragon more room to breathe */
            }
        }
    </style>
</head>
<body>
    <img id="logo" src="logo.png" alt="Raiku">

    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Collected: <span id="collected">0</span>/100</div>
        <div>Misses: <span id="misses">0</span>/14</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="winOverlay" class="overlay">
        Happy Valentine's Day from Raiku, love guaranteed!
        <br><button id="restartWinBtn">Play Again</button>
    </div>

    <div id="loseOverlay" class="overlay">
        game over, love not guaranteed ðŸ’”
        <br><button id="restartLoseBtn">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl    = document.getElementById('score');
        const collectedEl = document.getElementById('collected');
        const missesEl    = document.getElementById('misses');
        const winOverlay  = document.getElementById('winOverlay');
        const loseOverlay = document.getElementById('loseOverlay');

        const raikuImg = new Image();
        raikuImg.src = "white.png";

        let raikuImageLoaded = false;
        raikuImg.onload = () => { raikuImageLoaded = true; };

        function resizeCanvas() {
            const size = Math.min(window.innerWidth * 0.95, window.innerHeight * 0.85);
            canvas.width = size;
            canvas.height = size * 0.75;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let score = 0;
        let heartsCollected = 0;
        let misses = 0;
        const MAX_COLLECT = 100;
        const MAX_MISSES  = 14;
        let gameOver = false;
        let hearts = [];
        let particles = [];
        let shakeX = 0, shakeY = 0, shakeTime = 0;

        let raiku = { x: 0, y: 0, size: 0, targetX: 0, targetY: 0 };
        let pointerX = 0;
        let pointerY = 0;

        function resetGameState() {
            score = 0;
            heartsCollected = 0;
            misses = 0;
            gameOver = false;
            hearts = [];
            particles = [];
            shakeTime = 0;
            winOverlay.style.display = 'none';
            loseOverlay.style.display = 'none';
            pointerX = canvas.width / 2;
            pointerY = canvas.height - 120;
            raiku.x = canvas.width / 2;
            raiku.y = canvas.height - 120;
            raiku.targetX = raiku.x;
            raiku.targetY = raiku.y;
        }
        resetGameState();

        function updateRaiku() {
            // Larger dragon on mobile
            let sizeMultiplier = 0.06;                  // desktop/tablet
            if (window.innerWidth <= 768) {
                sizeMultiplier = 0.11;                 // noticeably bigger on phones
            }

            raiku.size = Math.min(canvas.width, canvas.height) * sizeMultiplier;

            raiku.targetX = Math.max(raiku.size / 2, Math.min(canvas.width - raiku.size / 2, pointerX));
            raiku.targetY = Math.max(raiku.size / 2, Math.min(canvas.height - raiku.size * 1.4, pointerY));
            raiku.x += (raiku.targetX - raiku.x) * 0.25;
            raiku.y += (raiku.targetY - raiku.y) * 0.25;
        }

        function drawHeart(x, y, size, glow = false) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(size/30, size/30);
            if (glow) {
                ctx.shadowColor = '#FF1493';
                ctx.shadowBlur = 25;
            }
            ctx.fillStyle = '#FF1493';
            ctx.beginPath();
            ctx.moveTo(15,10);
            ctx.bezierCurveTo(5,0,0,12,10,25);
            ctx.bezierCurveTo(20,12,15,0,15,10);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.beginPath();
            ctx.moveTo(12,8);
            ctx.bezierCurveTo(8,4,6,10,11,18);
            ctx.bezierCurveTo(16,10,14,6,12,8);
            ctx.fill();
            ctx.restore();
        }

        function drawRaiku(x, y, size) {
            if (!raikuImageLoaded) {
                ctx.fillStyle = "#4a8c4a";
                ctx.fillRect(x - size/2, y - size/2, size, size);
                return;
            }

            ctx.save();
            ctx.shadowColor   = '#C0FF38';
            ctx.shadowBlur    = 25;
            ctx.globalAlpha   = 1;

            const drawWidth  = size * 2.1;    // you can tune this further
            const drawHeight = size * 2.1;

            ctx.drawImage(
                raikuImg,
                x - drawWidth / 2,
                y - drawHeight / 2,
                drawWidth,
                drawHeight
            );

            ctx.restore();
        }

        function shakeScreen() { shakeTime = 8; }

        function updateShake() {
            if (shakeTime > 0) {
                shakeX = (Math.random()-0.5)*20;
                shakeY = (Math.random()-0.5)*20;
                shakeTime--;
            } else {
                shakeX *= 0.9;
                shakeY *= 0.9;
            }
        }

        function createParticles(x, y) {
            for (let i = 0; i < 25; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random()-0.5)*12,
                    vy: (Math.random()-0.5)*12 - 2,
                    life: 1,
                    size: Math.random()*8 + 4,
                    color: `hsl(79, 100%, ${50 + Math.random()*30}%)`
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length-1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx; p.y += p.vy; p.vy += 0.3; p.life -= 0.03; p.vx *= 0.98;
                if (p.life <= 0) particles.splice(i,1);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.shadowColor = p.color; ctx.shadowBlur = 15;
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            });
        }

        function spawnHeartFormation() {
            if (gameOver) return;
            const centerX = canvas.width / 2;
            const waves = 8, heartsPerWave = 5;
            for (let wave = 0; wave < waves; wave++) {
                for (let i = 0; i < heartsPerWave; i++) {
                    const angle  = (wave / waves) * Math.PI * 2;
                    const radius = 80 + wave * 25;
                    const x = centerX + Math.cos(angle) * radius + (Math.random()-0.5)*40;
                    const delay = wave * 100 + i * 50;
                    setTimeout(() => {
                        if (!gameOver) {
                            hearts.push({
                                x, y: -50,
                                vy: 2 + Math.random()*2,
                                size: 25 + Math.random()*15,
                                rot: 0,
                                rotSpeed: (Math.random()-0.5)*0.1
                            });
                        }
                    }, delay);
                }
            }
        }

        function checkCollisions() {
            for (let i = hearts.length-1; i >= 0; i--) {
                let h = hearts[i];
                let dx = h.x - raiku.x;
                let dy = h.y - raiku.y;
                let dist = Math.hypot(dx, dy);

                let hitRadius = 0.6;
                if (window.innerWidth <= 768) hitRadius = 0.75;  // easier to catch on mobile

                if (dist < raiku.size * hitRadius + h.size * 0.7) {
                    createParticles(h.x, h.y);
                    hearts.splice(i,1);
                    score += 15;
                    heartsCollected++;
                    if (heartsCollected >= MAX_COLLECT) {
                        gameOver = true;
                        winOverlay.style.display = 'block';
                    }
                    return;
                }
            }
        }

        function updateHearts() {
            for (let i = hearts.length-1; i >= 0; i--) {
                let h = hearts[i];
                h.y += h.vy;
                h.rot += h.rotSpeed;
                if (h.y > canvas.height + 50) {
                    hearts.splice(i,1);
                    misses++;
                    shakeScreen();
                    score = Math.max(0, score - 10);
                    if (misses >= MAX_MISSES) {
                        gameOver = true;
                        loseOverlay.style.display = 'block';
                    }
                }
            }
        }

        function handlePointer(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            pointerX = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            pointerY = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        }

        canvas.addEventListener('mousemove', handlePointer);
        canvas.addEventListener('touchmove', handlePointer);
        canvas.addEventListener('touchstart', handlePointer, {passive: false});
        canvas.addEventListener('touchend', e => e.preventDefault(), {passive: false});

        function gameLoop() {
            ctx.save();
            ctx.translate(shakeX, shakeY);
            ctx.clearRect(-shakeX, -shakeY, canvas.width, canvas.height);

            ctx.globalAlpha = 0.18;
            for (let i = 0; i < 8; i++) {
                let x = 100 + i*120 + Math.sin(Date.now()*0.001 + i)*30;
                drawHeart(x, 80 + Math.cos(Date.now()*0.001 + i)*20, 35);
            }
            ctx.globalAlpha = 1;

            if (!gameOver) {
                updateHearts();
                checkCollisions();
                updateRaiku();
            }

            updateShake();
            updateParticles();

            drawRaiku(raiku.x, raiku.y, raiku.size);

            hearts.forEach(h => {
                ctx.save();
                ctx.translate(h.x, h.y);
                ctx.rotate(h.rot);
                drawHeart(0, 0, h.size, true);
                ctx.restore();
            });

            drawParticles();

            scoreEl.textContent     = score;
            collectedEl.textContent = heartsCollected;
            missesEl.textContent    = misses;

            ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        setInterval(spawnHeartFormation, 4000);

        document.getElementById('restartWinBtn').onclick =
        document.getElementById('restartLoseBtn').onclick = resetGameState;

        gameLoop();
    </script>
</body>

</html>

